###########################################################
# TMUX functions

# This is used to establish a neutral symlink as ~/.ssh/ssh_auth_sock_for_tmux
# to the current ssh-agent socket. This symlink is the one tmux uses in the
# SSH_AUTH_SOCK variable stored when the tmux server is initialized.
#
# This ensures that all the shells generated by tmux have a reference to a
# static socket path that is not variable by process. (see ~/.tmux.conf for
# where the env variable is set for tmux, and why it gets inherited in each
# session.)
#
# If the ssh session is lost, then when a new session session is started, this
# method should be used again to bless the new SSH_AUTH_SOCK path as the
# ~/.ssh/ssh_auth_sock_for_tmux link so that when reattaching to tmux, ssh
# agent forwarding works again.
bless_ssh_auth_sock_for_tmux() {
  if [ -n "$SSH_AUTH_SOCK" ]; then
    ln -sf "$SSH_AUTH_SOCK" "$HOME/.ssh/ssh_auth_sock_for_tmux"
    export SSH_AUTH_SOCK
  fi
}

reattach_tmux() {
  bless_ssh_auth_sock_for_tmux
  tmux -S "/tmp/tmux-$(id -u)/pair" attach
}

# TMUX
############################################

############################################
# GIT

# Pull down the passed PR rom the upstream fork of the current github
# project
fetchpr () {
  pr_num=$1

  git fetch upstream "refs/pull/${pr_num}/head"
  git checkout -b "pull-${pr_num}" FETCH_HEAD
}

# List merged branches for cleanup
merged() {
  git branch --merged | grep -E '^(  )(issue|maint|task|ticket|tmp|feature|merge|fix|bug|PE-)'
}

# A git alias to manage $HOME dotfiles from the $HOME/.dotfiles repository
# See https://github.com/jpartlow/dotfiles/blob/master/README.md
function dotfiles {
  /usr/bin/git --git-dir="$HOME/.dotfiles/" --work-tree="$HOME" "$@"
}

find_local_git_changes() {
  local path=${1:-$(pwd)}
  local git_executable=${2:-git}
  typeset -i exitcode=0

  pushd "$path" > /dev/null

  local output
  output=$($git_executable -c color.status=always status -s)

  local missing_branches
  missing_branches=()
  for branch in $($git_executable for-each-ref refs/heads --format '%(refname:strip=2)') ; do
    local found_in_a_remote
    found_in_a_remote=$($git_executable branch -r --contains "$branch")
    if [ -z "${found_in_a_remote}" ]; then
      missing_branches+="$branch"
    fi
  done

  if [ -n "$output" ] || [ "${#missing_branches[*]}" != "0" ]; then

    echo "---------------------------------------------"
    echo "${path}"

    if [ -n "$output" ]; then
      echo " -> local changes found:"
      echo "$output"
      echo
    fi

    if [ "${#missing_branches[*]}" != "0" ]; then
      echo " -> unmerged branches found:"
      for branch in ${missing_branches[*]}; do
        echo "$branch"
      done
    fi

    echo "---------------------------------------------"
    echo

    exitcode=1
  fi

  popd > /dev/null

  return $exitcode
}

# Warn if any git repository found along this path has uncommitted changes
# or unpushed branches, since workstations are ephemeral.
warn_for_local_changes() {
  local path=${1:?}

  # just directories in this directory (skip '.')
  local dirs
  dirs=$(find "$path" -maxdepth 1 -mindepth 1 -type d -name '[^.]*')
  typeset -i exitcode=0

  for d in $dirs; do
    if [ -d "${d}/.git" ]; then
      if ! find_local_git_changes "${d}"; then
        exitcode=1
      fi
    else
      warn_for_local_changes "${d}"
    fi
  done

  return $exitcode
}

check_repos() {
  warn_for_local_changes "${HOME}/work/src"
  local src_exit=$?
  find_local_git_changes "$HOME" dotfiles
  local dot_exit=$?
  [ "$src_exit" == '0' ] && [ "$dot_exit" == '0' ]
}

# GIT
############################################

# vim: ft=sh
